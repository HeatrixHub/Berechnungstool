diff --git a/Isolierung/core/database.py b/Isolierung/core/database.py
index 918632275c67ec1cccadf716d51c2cf76c253632..febdaef1230bbfc065b9c59dd0392107009c53aa 100644
--- a/Isolierung/core/database.py
+++ b/Isolierung/core/database.py
@@ -1,72 +1,84 @@
 """
 database.py
 Verwaltet alle Projekt- und Material-Operationen in einer zentralen SQLite-Datenbank.
 """
 
 from __future__ import annotations
 
 import json
 import sqlite3
 from pathlib import Path
 from typing import Any, Dict, List, Optional, Sequence, Tuple
 
 from .models import (
     Material,
     MaterialMeasurement,
+    MaterialVariant,
     Project,
     ProjectLayer,
     ProjectResult,
 )
 
 DB_PATH = "heatrix.db"
 LEGACY_PROJECT_DB = "projects.db"
-LEGACY_MATERIAL_DB = "heatrix_data.db"
 
 
 def _get_connection() -> sqlite3.Connection:
     conn = sqlite3.connect(DB_PATH)
     conn.row_factory = sqlite3.Row
     conn.execute("PRAGMA foreign_keys = ON")
     return conn
 
 
 def _ensure_schema_meta(conn: sqlite3.Connection) -> int:
     conn.execute(
         """
         CREATE TABLE IF NOT EXISTS schema_meta (
             id INTEGER PRIMARY KEY CHECK (id = 1),
             version INTEGER NOT NULL
         )
         """
     )
     row = conn.execute("SELECT version FROM schema_meta WHERE id = 1").fetchone()
     if row is None:
         conn.execute("INSERT INTO schema_meta (id, version) VALUES (1, 0)")
         conn.commit()
         return 0
-    return int(row["version"])
+
+    version = int(row["version"])
+
+    if version >= 4:
+        has_variants = conn.execute(
+            "SELECT name FROM sqlite_master WHERE type='table' AND name='material_variants'"
+        ).fetchone()
+        if not has_variants:
+            version = 3
+            conn.execute("UPDATE schema_meta SET version = ? WHERE id = 1", (version,))
+            conn.commit()
+
+    return version
 
 
 def _migration_1(conn: sqlite3.Connection) -> None:
     conn.executescript(
         """
         CREATE TABLE IF NOT EXISTS projects (
             id INTEGER PRIMARY KEY AUTOINCREMENT,
             name TEXT NOT NULL UNIQUE,
             T_left REAL NOT NULL,
             T_inf REAL NOT NULL,
             h REAL NOT NULL,
             created_by TEXT,
             created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
             updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
         );
 
         CREATE TABLE IF NOT EXISTS materials (
             id INTEGER PRIMARY KEY AUTOINCREMENT,
             name TEXT NOT NULL UNIQUE,
             classification_temp REAL,
             density REAL,
             length REAL,
             width REAL,
             height REAL,
             price REAL,
@@ -135,72 +147,115 @@ def _migration_3(conn: sqlite3.Connection) -> None:
         """
         CREATE TABLE IF NOT EXISTS project_layers_new (
             id INTEGER PRIMARY KEY AUTOINCREMENT,
             project_id INTEGER NOT NULL,
             material_id INTEGER NOT NULL,
             order_index INTEGER NOT NULL,
             thickness REAL NOT NULL,
             custom_name TEXT,
             FOREIGN KEY(project_id) REFERENCES projects(id) ON DELETE CASCADE,
             FOREIGN KEY(material_id) REFERENCES materials(id) ON DELETE CASCADE,
             UNIQUE(project_id, order_index)
         );
 
         INSERT INTO project_layers_new (project_id, material_id, order_index, thickness, custom_name)
         SELECT project_id, material_id, order_index, thickness, custom_name FROM project_layers;
 
         DROP TABLE project_layers;
         ALTER TABLE project_layers_new RENAME TO project_layers;
 
         CREATE INDEX IF NOT EXISTS idx_project_layers_project ON project_layers(project_id);
         CREATE INDEX IF NOT EXISTS idx_project_layers_material ON project_layers(material_id);
         """
     )
 
 
+def _migration_4(conn: sqlite3.Connection) -> None:
+    conn.executescript(
+        """
+        CREATE TABLE IF NOT EXISTS material_variants (
+            id INTEGER PRIMARY KEY AUTOINCREMENT,
+            material_id INTEGER NOT NULL,
+            name TEXT NOT NULL,
+            thickness REAL NOT NULL,
+            length REAL,
+            width REAL,
+            height REAL,
+            price REAL,
+            created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
+            updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
+            FOREIGN KEY(material_id) REFERENCES materials(id) ON DELETE CASCADE,
+            UNIQUE(material_id, name)
+        );
+
+        CREATE INDEX IF NOT EXISTS idx_material_variants_material ON material_variants(material_id);
+        """
+    )
+
+    rows = conn.execute(
+        "SELECT id, name, length, width, height, price FROM materials"
+    ).fetchall()
+    for row in rows:
+        conn.execute(
+            """
+            INSERT OR IGNORE INTO material_variants (
+                material_id, name, thickness, length, width, price
+            ) VALUES (?, ?, ?, ?, ?, ?)
+            """,
+            (
+                row["id"],
+                "Standard",
+                row["height"] if row["height"] is not None else 0.0,
+                row["length"],
+                row["width"],
+                row["price"],
+            ),
+        )
+
+
 MIGRATIONS: Sequence[Tuple[int, Any]] = [
     (1, _migration_1),
     (2, _migration_2),
     (3, _migration_3),
+    (4, _migration_4),
 ]
 
 
 def _run_migrations() -> None:
     with _get_connection() as conn:
         current_version = _ensure_schema_meta(conn)
         for version, migration in MIGRATIONS:
             if version > current_version:
                 migration(conn)
                 conn.execute("UPDATE schema_meta SET version = ? WHERE id = 1", (version,))
                 conn.commit()
                 current_version = version
 
 
 def _migrate_legacy_data() -> None:
     with _get_connection() as conn:
         _migrate_legacy_projects(conn)
-        _migrate_legacy_materials(conn)
 
 
 def _migrate_legacy_projects(conn: sqlite3.Connection) -> None:
     legacy_path = Path(LEGACY_PROJECT_DB)
     if not legacy_path.exists():
         return
     existing = conn.execute("SELECT COUNT(1) FROM projects").fetchone()[0]
     if existing:
         return
     legacy_conn = sqlite3.connect(str(legacy_path))
     legacy_conn.row_factory = sqlite3.Row
     try:
         rows = legacy_conn.execute(
             "SELECT name, thicknesses, isolierungen, T_left, T_inf, h, result FROM projects"
         ).fetchall()
     except sqlite3.OperationalError:
         rows = legacy_conn.execute(
             "SELECT name, thicknesses, '' AS isolierungen, T_left, T_inf, h, result FROM projects"
         ).fetchall()
     for row in rows:
         try:
             thicknesses = json.loads(row["thicknesses"]) if row["thicknesses"] else []
         except json.JSONDecodeError:
             thicknesses = []
         isolierungen_raw = row["isolierungen"]
@@ -209,93 +264,50 @@ def _migrate_legacy_projects(conn: sqlite3.Connection) -> None:
             try:
                 isolierungen = json.loads(isolierungen_raw)
             except json.JSONDecodeError:
                 isolierungen = []
         else:
             isolierungen = [f"Schicht {i+1}" for i in range(len(thicknesses))]
         result_raw = row["result"]
         try:
             result = json.loads(result_raw) if result_raw else {}
         except json.JSONDecodeError:
             result = {}
         _persist_project(
             conn,
             name=row["name"],
             thicknesses=thicknesses,
             isolierungen=isolierungen,
             T_left=row["T_left"],
             T_inf=row["T_inf"],
             h=row["h"],
             result=result,
             version_label="legacy",
         )
     legacy_conn.close()
 
 
-def _migrate_legacy_materials(conn: sqlite3.Connection) -> None:
-    legacy_path = Path(LEGACY_MATERIAL_DB)
-    if not legacy_path.exists():
-        return
-    existing = conn.execute("SELECT COUNT(1) FROM materials").fetchone()[0]
-    if existing:
-        return
-    legacy_conn = sqlite3.connect(str(legacy_path))
-    legacy_conn.row_factory = sqlite3.Row
-    try:
-        rows = legacy_conn.execute(
-            "SELECT name, classification_temp, density, temps, ks FROM insulations"
-        ).fetchall()
-    except sqlite3.OperationalError:
-        rows = []
-    for row in rows:
-        temps = _safe_load_json(row["temps"]) if row["temps"] else []
-        ks = _safe_load_json(row["ks"]) if row["ks"] else []
-        _persist_material(
-            conn,
-            name=row["name"],
-            classification_temp=row["classification_temp"],
-            density=row["density"],
-            length=None,
-            width=None,
-            height=None,
-            price=None,
-            temps=temps,
-            ks=ks,
-        )
-    legacy_conn.close()
-
-
-def _safe_load_json(payload: str) -> List[float]:
-    try:
-        data = json.loads(payload)
-        if isinstance(data, list):
-            return data
-    except json.JSONDecodeError:
-        pass
-    return []
-
-
 def _normalize_material_name(name: str, fallback_index: int | None = None) -> str:
     normalized = (name or "").strip()
     if normalized:
         return normalized
     if fallback_index is not None:
         return f"Schicht {fallback_index + 1}"
     return "Unbenannte Isolierung"
 
 
 def _ensure_material(conn: sqlite3.Connection, name: str) -> int:
     row = conn.execute("SELECT id FROM materials WHERE name = ?", (name,)).fetchone()
     if row:
         return int(row["id"])
     conn.execute("INSERT INTO materials (name) VALUES (?)", (name,))
     row = conn.execute("SELECT id FROM materials WHERE name = ?", (name,)).fetchone()
     if not row:
         raise RuntimeError(f"Material '{name}' konnte nicht erstellt werden.")
     return int(row["id"])
 
 
 def _persist_project(
     conn: sqlite3.Connection,
     *,
     name: str,
     thicknesses: Sequence[float],
@@ -345,72 +357,64 @@ def _persist_project(
     cursor.execute(
         "DELETE FROM project_results WHERE project_id = ? AND version_label = ?",
         (project_id, version_label),
     )
     if result is not None:
         cursor.execute(
             """
             INSERT INTO project_results (project_id, version_label, data)
             VALUES (?, ?, ?)
             ON CONFLICT(project_id, version_label) DO UPDATE SET
                 data = excluded.data,
                 created_at = CURRENT_TIMESTAMP
             """,
             (project_id, version_label, json.dumps(result)),
         )
     conn.commit()
     return True
 
 
 def _persist_material(
     conn: sqlite3.Connection,
     *,
     name: str,
     classification_temp: Optional[float],
     density: Optional[float],
-    length: Optional[float],
-    width: Optional[float],
-    height: Optional[float],
-    price: Optional[float],
     temps: Sequence[float],
     ks: Sequence[float],
 ) -> bool:
     cursor = conn.cursor()
     cursor.execute(
         """
-        INSERT INTO materials (name, classification_temp, density, length, width, height, price)
-        VALUES (?, ?, ?, ?, ?, ?, ?)
+        INSERT INTO materials (name, classification_temp, density)
+        VALUES (?, ?, ?)
         ON CONFLICT(name) DO UPDATE SET
             classification_temp = excluded.classification_temp,
             density = excluded.density,
-            length = excluded.length,
-            width = excluded.width,
-            height = excluded.height,
-            price = excluded.price,
             updated_at = CURRENT_TIMESTAMP
         """,
-        (name, classification_temp, density, length, width, height, price),
+        (name, classification_temp, density),
     )
     material_id = cursor.execute("SELECT id FROM materials WHERE name = ?", (name,)).fetchone()["id"]
     cursor.execute("DELETE FROM material_measurements WHERE material_id = ?", (material_id,))
     ordered_pairs = sorted(zip(temps, ks), key=lambda pair: pair[0])
     for temp, k_val in ordered_pairs:
         cursor.execute(
             "INSERT INTO material_measurements (material_id, temperature, conductivity) VALUES (?, ?, ?)",
             (material_id, float(temp), float(k_val)),
         )
     conn.commit()
     return True
 
 
 def save_project(
     name: str,
     thicknesses: Sequence[float],
     isolierungen: Sequence[str],
     T_left: float,
     T_inf: float,
     h: float,
     result: Optional[Dict],
     *,
     created_by: Optional[str] = None,
     version_label: str = "latest",
 ) -> bool:
@@ -541,147 +545,224 @@ def list_projects_overview() -> List[Dict[str, Any]]:
                     p.updated_at,
                     COUNT(l.id) AS layer_count
                 FROM projects p
                 LEFT JOIN project_layers l ON l.project_id = p.id
                 GROUP BY p.id
                 ORDER BY p.name COLLATE NOCASE
                 """
             ).fetchall()
             return [
                 {
                     "name": row["name"],
                     "T_left": row["T_left"],
                     "T_inf": row["T_inf"],
                     "h": row["h"],
                     "created_at": row["created_at"],
                     "updated_at": row["updated_at"],
                     "layer_count": row["layer_count"],
                 }
                 for row in rows
             ]
     except Exception as exc:
         print(f"[DB] Fehler beim Abrufen der Projektübersicht: {exc}")
         return []
 
 
+def _load_variants_for_materials(
+    conn: sqlite3.Connection, material_ids: Sequence[int]
+) -> Dict[int, List[MaterialVariant]]:
+    if not material_ids:
+        return {}
+    placeholders = ",".join(["?"] * len(material_ids))
+    rows = conn.execute(
+        f"""
+        SELECT material_id, name, thickness, length, width, price
+        FROM material_variants
+        WHERE material_id IN ({placeholders})
+        ORDER BY thickness ASC
+        """,
+        list(material_ids),
+    ).fetchall()
+    variants: Dict[int, List[MaterialVariant]] = {}
+    for row in rows:
+        variants.setdefault(row["material_id"], []).append(
+            MaterialVariant(
+                name=row["name"],
+                thickness=row["thickness"],
+                length=row["length"],
+                width=row["width"],
+                price=row["price"],
+            )
+        )
+    return variants
+
+
 def list_materials() -> List[Material]:
     try:
         with _get_connection() as conn:
             rows = conn.execute(
                 """
                 SELECT
-                    name,
-                    classification_temp,
-                    density,
-                    length,
-                    width,
-                    height,
-                    price,
-                    created_at,
-                    updated_at
-                FROM materials
-                ORDER BY name COLLATE NOCASE
+                    m.id,
+                    m.name,
+                    m.classification_temp,
+                    m.density,
+                    m.created_at,
+                    m.updated_at
+                FROM materials m
+                ORDER BY m.name COLLATE NOCASE
                 """
             ).fetchall()
+            variants = _load_variants_for_materials(conn, [row["id"] for row in rows])
             return [
                 Material(
                     name=row["name"],
                     classification_temp=row["classification_temp"],
                     density=row["density"],
-                    length=row["length"],
-                    width=row["width"],
-                    height=row["height"],
-                    price=row["price"],
+                    variants=variants.get(row["id"], []),
                     created_at=row["created_at"],
                     updated_at=row["updated_at"],
                 )
                 for row in rows
             ]
     except Exception as exc:
         print(f"[DB] Fehler beim Abrufen der Materialien: {exc}")
         return []
 
 
 def load_material(name: str) -> Optional[Material]:
     try:
         with _get_connection() as conn:
             row = conn.execute(
                 "SELECT * FROM materials WHERE name = ?",
                 (name,),
             ).fetchone()
             if not row:
                 return None
+            variants = _load_variants_for_materials(conn, [row["id"]]).get(
+                row["id"], []
+            )
             measurement_rows = conn.execute(
                 "SELECT temperature, conductivity FROM material_measurements WHERE material_id = ? ORDER BY temperature ASC",
                 (row["id"],),
             ).fetchall()
             measurements = [
                 MaterialMeasurement(temperature=m["temperature"], conductivity=m["conductivity"])
                 for m in measurement_rows
             ]
             return Material(
                 name=row["name"],
                 classification_temp=row["classification_temp"],
                 density=row["density"],
-                length=row["length"],
-                width=row["width"],
-                height=row["height"],
-                price=row["price"],
+                variants=variants,
                 measurements=measurements,
                 created_at=row["created_at"],
                 updated_at=row["updated_at"],
             )
     except Exception as exc:
         print(f"[DB] Fehler beim Laden des Materials '{name}': {exc}")
         return None
 
 
-def save_material(
+def save_material_family(
     name: str,
     classification_temp: Optional[float],
     density: Optional[float],
-    length: Optional[float],
-    width: Optional[float],
-    height: Optional[float],
-    price: Optional[float],
     temps: Sequence[float],
     ks: Sequence[float],
 ) -> bool:
     try:
         with _get_connection() as conn:
             return _persist_material(
                 conn,
                 name=name,
                 classification_temp=classification_temp,
                 density=density,
-                length=length,
-                width=width,
-                height=height,
-                price=price,
                 temps=temps,
                 ks=ks,
             )
     except Exception as exc:
-        print(f"[DB] Fehler beim Speichern der Isolierung '{name}': {exc}")
+        print(f"[DB] Fehler beim Speichern der Materialfamilie '{name}': {exc}")
+        return False
+
+
+def save_material_variant(
+    material_name: str,
+    variant_name: str,
+    thickness: float,
+    length: Optional[float],
+    width: Optional[float],
+    price: Optional[float],
+) -> bool:
+    try:
+        with _get_connection() as conn:
+            cursor = conn.execute("SELECT id FROM materials WHERE name = ?", (material_name,))
+            row = cursor.fetchone()
+            if not row:
+                return False
+            conn.execute(
+                """
+                INSERT INTO material_variants (
+                    material_id, name, thickness, length, width, price
+                ) VALUES (?, ?, ?, ?, ?, ?)
+                ON CONFLICT(material_id, name) DO UPDATE SET
+                    thickness=excluded.thickness,
+                    length=excluded.length,
+                    width=excluded.width,
+                    price=excluded.price,
+                    updated_at=CURRENT_TIMESTAMP
+                """,
+                (
+                    row["id"],
+                    variant_name,
+                    thickness,
+                    length,
+                    width,
+                    price,
+                ),
+            )
+            conn.commit()
+            return True
+    except Exception as exc:
+        print(f"[DB] Fehler beim Speichern der Variante '{variant_name}': {exc}")
         return False
 
 
 def delete_material(name: str) -> bool:
     try:
         with _get_connection() as conn:
             cursor = conn.cursor()
             row = cursor.execute(
                 "SELECT id FROM materials WHERE name = ?", (name,),
             ).fetchone()
             if not row:
                 return False
 
             cursor.execute("DELETE FROM materials WHERE id = ?", (row["id"],))
             conn.commit()
             return cursor.rowcount > 0
     except Exception as exc:
         print(f"[DB] Fehler beim Löschen der Isolierung '{name}': {exc}")
         return False
 
 
+def delete_material_variant(material_name: str, variant_name: str) -> bool:
+    try:
+        with _get_connection() as conn:
+            material_row = conn.execute(
+                "SELECT id FROM materials WHERE name = ?", (material_name,)
+            ).fetchone()
+            if not material_row:
+                return False
+            cursor = conn.execute(
+                "DELETE FROM material_variants WHERE material_id = ? AND name = ?",
+                (material_row["id"], variant_name),
+            )
+            conn.commit()
+            return cursor.rowcount > 0
+    except Exception as exc:
+        print(f"[DB] Fehler beim Löschen der Variante '{variant_name}': {exc}")
+        return False
+
+
 _run_migrations()
 _migrate_legacy_data()
diff --git a/Isolierung/core/models.py b/Isolierung/core/models.py
index 7ab07ae8fe9d659af1b6f7985bd2162969af38b5..c3a0fb01629e4c2f8dd64122aa68ed1e960fc776 100644
--- a/Isolierung/core/models.py
+++ b/Isolierung/core/models.py
@@ -1,72 +1,94 @@
 """
 models.py
 Definiert die zentralen Datenstrukturen für Projekte und Materialien.
 """
 
 from dataclasses import dataclass, field
 from typing import Dict, List, Optional
 
 
+@dataclass
+class MaterialVariant:
+    """Eine konkrete Ausführung einer Isolierung innerhalb einer Materialfamilie."""
+
+    name: str
+    thickness: float
+    length: Optional[float] = None
+    width: Optional[float] = None
+    price: Optional[float] = None
+
+    def to_dict(self) -> Dict:
+        return {
+            "name": self.name,
+            "thickness": self.thickness,
+            "length": self.length,
+            "width": self.width,
+            "price": self.price,
+        }
+
+
 @dataclass
 class MaterialMeasurement:
     """Ein einzelner Messpunkt für eine Isolierung (Temperatur vs. k)."""
 
     temperature: float
     conductivity: float
 
 
 @dataclass
 class Material:
     """Beschreibt eine Isolierung inkl. optionaler Messdaten."""
 
     name: str
     classification_temp: Optional[float] = None
     density: Optional[float] = None
     length: Optional[float] = None
     width: Optional[float] = None
     height: Optional[float] = None
     price: Optional[float] = None
     measurements: List[MaterialMeasurement] = field(default_factory=list)
+    variants: List[MaterialVariant] = field(default_factory=list)
     created_at: Optional[str] = None
     updated_at: Optional[str] = None
 
     def to_dict(self, include_measurements: bool = True) -> Dict:
         data = {
             "name": self.name,
             "classification_temp": self.classification_temp,
             "density": self.density,
             "length": self.length,
             "width": self.width,
             "height": self.height,
             "price": self.price,
             "created_at": self.created_at,
             "updated_at": self.updated_at,
         }
         if include_measurements:
             data["temps"] = [m.temperature for m in self.measurements]
             data["ks"] = [m.conductivity for m in self.measurements]
+        data["variants"] = [variant.to_dict() for variant in self.variants]
         return data
 
 
 @dataclass
 class ProjectLayer:
     """Eine Schicht eines Projektes."""
 
     order_index: int
     thickness: float
     material_name: str
 
 
 @dataclass
 class ProjectResult:
     """Meta-Informationen zu einem gespeicherten Berechnungsergebnis."""
 
     version_label: str = "latest"
     data: Optional[Dict] = None
     created_at: Optional[str] = None
 
 
 @dataclass
 class Project:
     """Bündelt alle relevanten Projektdaten und Ergebnisse."""
 
diff --git a/app/global_tabs/isolierungen_db/logic.py b/app/global_tabs/isolierungen_db/logic.py
index a4c09f0991ebd7c6145b630f0012e80644059980..4a4f9522cbb57b02c6a70c399512b2dda63f163b 100644
--- a/app/global_tabs/isolierungen_db/logic.py
+++ b/app/global_tabs/isolierungen_db/logic.py
@@ -1,135 +1,148 @@
 """
 Gemeinsame Logik für die Verwaltung von Isolierungen.
 Ermöglicht das Speichern, Laden, Bearbeiten und Löschen von Isolierungen
 sowie die Interpolation der Wärmeleitfähigkeit.
 """
 from __future__ import annotations
 
 from typing import Callable, Dict, List, Tuple
 
 import csv
 import re
 from datetime import datetime
 from pathlib import Path
 from dataclasses import dataclass
 
 import numpy as np
 
 from Isolierung.core.database import (
     delete_material,
+    delete_material_variant,
     list_materials,
     load_material,
-    save_material,
+    save_material_family,
+    save_material_variant,
 )
 
 
 _material_change_listeners: set[Callable[[], None]] = set()
 
 
 def register_material_change_listener(callback: Callable[[], None]) -> None:
     """Registriert eine Callback-Funktion, die bei Materialänderungen aufgerufen wird."""
 
     _material_change_listeners.add(callback)
 
 
 def unregister_material_change_listener(callback: Callable[[], None]) -> None:
     """Hebt die Registrierung eines Material-Listeners auf (falls vorhanden)."""
 
     _material_change_listeners.discard(callback)
 
 
 def _notify_material_change_listeners() -> None:
     """Benachrichtigt alle registrierten Listener über geänderte Materialien."""
 
     for listener in list(_material_change_listeners):
         try:
             listener()
         except Exception:
             # Wir protokollieren Fehler nur in der Konsole, um die GUI reaktionsfähig zu halten.
             import traceback
 
             traceback.print_exc()
 
 
 def get_all_insulations() -> List[Dict]:
     materials = list_materials()
     return [
         {
             "name": material.name,
             "classification_temp": material.classification_temp,
             "density": material.density,
-            "length": material.length,
-            "width": material.width,
-            "height": material.height,
-            "price": material.price,
+            "variant_count": len(material.variants),
         }
         for material in materials
     ]
 
 
 def load_insulation(name: str) -> Dict:
     material = load_material(name)
     if not material:
         return {}
     return material.to_dict(include_measurements=True)
 
 
-def save_insulation(
+def save_family(
     name: str,
-    classification_temp: float,
-    density: float,
+    classification_temp: float | None,
+    density: float | None,
+    temps: List[float],
+    ks: List[float],
+) -> bool:
+    saved = save_material_family(name, classification_temp, density, temps, ks)
+    if saved:
+        _notify_material_change_listeners()
+    return saved
+
+
+def save_variant(
+    material_name: str,
+    variant_name: str,
+    thickness: float,
     length: float | None,
     width: float | None,
-    height: float | None,
     price: float | None,
-    temps: List[float],
-    ks: List[float],
 ) -> bool:
-    saved = save_material(
-        name,
-        classification_temp,
-        density,
+    saved = save_material_variant(
+        material_name,
+        variant_name,
+        thickness,
         length,
         width,
-        height,
         price,
-        temps,
-        ks,
     )
     if saved:
         _notify_material_change_listeners()
     return saved
 
 
 def delete_insulation(name: str):
     deleted = delete_material(name)
     if deleted:
         _notify_material_change_listeners()
     return deleted
 
 
+def delete_variant(material_name: str, variant_name: str) -> bool:
+    deleted = delete_material_variant(material_name, variant_name)
+    if deleted:
+        _notify_material_change_listeners()
+    return deleted
+
+
 def interpolate_k(temps: List[float], ks: List[float], x_range: np.ndarray):
     """
     Interpoliert/approximiert Wärmeleitfähigkeit k(T) über x_range.
     - >=3 Messpunkte: quadratische Anpassung (Polyfit deg=2)
     - 2 Messpunkte: lineare Anpassung
     - 1 Messpunkt: konstante k
     Rückgabe: np.ndarray mit k-Werten für x_range (gleiche Länge)
     """
     if len(temps) == 0 or len(ks) == 0:
         raise ValueError("Keine Temperatur- oder k-Werte übergeben.")
 
     temps_arr = np.array(temps, dtype=float)
     ks_arr = np.array(ks, dtype=float)
     order = np.argsort(temps_arr)
     temps_arr = temps_arr[order]
     ks_arr = ks_arr[order]
 
     unique_temps: List[float] = []
     unique_ks: List[float] = []
     i = 0
     n = len(temps_arr)
     while i < n:
         t = temps_arr[i]
         same_idx = np.where(np.isclose(temps_arr, t))[0]
         same_idx = same_idx[same_idx >= i]
@@ -140,200 +153,205 @@ def interpolate_k(temps: List[float], ks: List[float], x_range: np.ndarray):
             i = int(same_idx[-1] + 1)
         else:
             unique_temps.append(float(t))
             unique_ks.append(float(ks_arr[i]))
             i += 1
 
     temps_u = np.array(unique_temps)
     ks_u = np.array(unique_ks)
 
     if temps_u.size >= 3:
         coeffs = np.polyfit(temps_u, ks_u, 2)
         k_fit = np.polyval(coeffs, x_range)
     elif temps_u.size == 2:
         coeffs = np.polyfit(temps_u, ks_u, 1)
         k_fit = np.polyval(coeffs, x_range)
     else:
         k_fit = np.full_like(x_range, ks_u[0], dtype=float)
 
     return k_fit
 
 
 CSV_HEADERS = [
     "name",
     "classification_temp",
     "density",
+    "temps",
+    "ks",
+    "variant_name",
+    "thickness",
     "length",
     "width",
-    "height",
     "price",
-    "temps",
-    "ks",
 ]
 
-REQUIRED_HEADERS = {"name", "temps", "ks"}
+LEGACY_HEADERS = {"height"}
+
+REQUIRED_HEADERS = {"name", "variant_name", "thickness", "temps", "ks"}
 
 
 @dataclass
 class FileImportResult:
     file_path: str
     imported: int
     errors: List[str]
     skipped_reason: str | None = None
 
 
 def export_insulations_to_csv(names: List[str], file_path: str) -> Tuple[int, List[str]]:
     """Exportiert ausgewählte Isolierungen in eine einzige CSV-Datei.
 
     Returns:
         Tuple[int, List[str]]: Anzahl erfolgreich exportierter Datensätze und Namen,
         die nicht geladen werden konnten.
     """
 
     failed: List[str] = []
     exported = 0
     with open(file_path, "w", newline="", encoding="utf-8") as csvfile:
         writer = csv.DictWriter(csvfile, fieldnames=CSV_HEADERS)
         writer.writeheader()
         for name in names:
-            row = _build_insulation_row(name)
-            if row is None:
+            rows = _build_insulation_rows(name)
+            if rows is None:
                 failed.append(name)
                 continue
-            writer.writerow(row)
-            exported += 1
+            for row in rows:
+                writer.writerow(row)
+                exported += 1
     return exported, failed
 
 
 def export_insulations_to_folder(
     names: List[str], target_directory: str
 ) -> Tuple[int, List[str], str]:
     """Exportiert mehrere Isolierungen als einzelne CSV-Dateien in einem neuen Ordner."""
 
     timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
     base_dir = Path(target_directory)
     export_dir = base_dir / f"isolierungen_export_{timestamp}"
     export_dir.mkdir(parents=True, exist_ok=False)
 
     failed: List[str] = []
     exported = 0
     used_names: set[str] = set()
 
     for name in names:
-        row = _build_insulation_row(name)
-        if row is None:
+        rows = _build_insulation_rows(name)
+        if rows is None:
             failed.append(name)
             continue
 
         safe_name = _sanitize_filename(name)
         candidate = safe_name
         counter = 1
         while candidate in used_names or (export_dir / f"{candidate}.csv").exists():
             candidate = f"{safe_name}_{counter}"
             counter += 1
         used_names.add(candidate)
 
         file_path = export_dir / f"{candidate}.csv"
         with open(file_path, "w", newline="", encoding="utf-8") as csvfile:
             writer = csv.DictWriter(csvfile, fieldnames=CSV_HEADERS)
             writer.writeheader()
-            writer.writerow(row)
-        exported += 1
+            for row in rows:
+                writer.writerow(row)
+        exported += len(rows)
 
     return exported, failed, str(export_dir)
 
 
 def import_insulations_from_csv_files(
     file_paths: List[str],
 ) -> Tuple[int, List[FileImportResult]]:
     """Importiert Isolierungen aus mehreren CSV-Dateien.
 
     Jeder Dateipfad wird einzeln validiert (Encoding, Kopfzeilen, Pflichtfelder).
     Bei Dateifehlern wird die Datei übersprungen, gültige Dateien werden Zeile für
     Zeile verarbeitet. Pro Zeile wird entweder ein vollständiger Datensatz
     gespeichert oder verworfen.
 
     Returns:
         Gesamtzahl importierter Datensätze und eine Liste mit Dateiergebnissen.
     """
 
     existing_names = {material.name for material in list_materials()}
+    canonical_names: dict[str, str] = {}
     results: List[FileImportResult] = []
     total_imported = 0
 
     for file_path in file_paths:
         imported = 0
         errors: List[str] = []
 
         try:
             with open(file_path, newline="", encoding="utf-8") as csvfile:
                 reader = csv.DictReader(csvfile)
                 validation_error = _validate_csv_headers(reader.fieldnames)
                 if validation_error:
                     results.append(
                         FileImportResult(
                             file_path=file_path,
                             imported=0,
                             errors=[],
                             skipped_reason=validation_error,
                         )
                     )
                     continue
 
                 for idx, row in enumerate(reader, start=2):
                     base_name = (row.get("name") or "").strip()
+                    variant_name = (row.get("variant_name") or "").strip() or "Standard"
                     try:
-                        _ensure_required_fields(base_name)
+                        _ensure_required_fields(base_name, variant_name)
                         class_temp = _parse_optional_float(
                             row.get("classification_temp")
                         )
                         density = _parse_optional_float(row.get("density"))
                         length = _parse_optional_float(row.get("length"))
                         width = _parse_optional_float(row.get("width"))
-                        height = _parse_optional_float(row.get("height"))
                         price = _parse_optional_float(row.get("price"))
+                        thickness = _parse_optional_float(row.get("thickness"))
+                        if thickness is None:
+                            raise ValueError("Pflichtfeld 'thickness' fehlt oder ist leer.")
                         temps = _parse_numeric_list(row.get("temps", ""))
                         ks = _parse_numeric_list(row.get("ks", ""))
                         if len(temps) != len(ks):
                             raise ValueError(
                                 "Temperatur- und k-Liste müssen gleich lang sein."
                             )
 
-                        name = _generate_unique_name(base_name, existing_names)
-                        saved = save_insulation(
-                            name,
-                            class_temp if class_temp is not None else 0.0,
-                            density if density is not None else 0.0,
-                            length,
-                            width,
-                            height,
-                            price,
-                            temps,
-                            ks,
-                        )
-                        if not saved:
-                            raise ValueError("Speichern fehlgeschlagen.")
+                        if base_name not in canonical_names:
+                            canonical_names[base_name] = _generate_unique_name(
+                                base_name, existing_names
+                            )
+                        name = canonical_names[base_name]
+
+                        if not save_family(name, class_temp, density, temps, ks):
+                            raise ValueError("Stammdaten konnten nicht gespeichert werden.")
+                        if not save_variant(name, variant_name, thickness, length, width, price):
+                            raise ValueError("Variante konnte nicht gespeichert werden.")
                         imported += 1
                     except Exception as exc:  # pragma: no cover - Laufzeitvalidierung
                         display_name = base_name or "<unbenannt>"
                         errors.append(f"Zeile {idx} ({display_name}): {exc}")
 
         except UnicodeDecodeError as exc:
             results.append(
                 FileImportResult(
                     file_path=file_path,
                     imported=0,
                     errors=[],
                     skipped_reason=f"Ungültiges Encoding: {exc}",
                 )
             )
             continue
         except Exception as exc:
             results.append(
                 FileImportResult(
                     file_path=file_path,
                     imported=0,
                     errors=[],
                     skipped_reason=f"Datei konnte nicht gelesen werden: {exc}",
                 )
             )
             continue
@@ -345,74 +363,89 @@ def import_insulations_from_csv_files(
             )
         )
 
     if total_imported:
         _notify_material_change_listeners()
 
     return total_imported, results
 
 
 def _parse_optional_float(value: str | None) -> float | None:
     if value is None:
         return None
     cleaned = str(value).strip()
     if not cleaned:
         return None
     return float(cleaned)
 
 
 def _parse_numeric_list(value: str) -> List[float]:
     cleaned = (value or "").strip()
     if not cleaned:
         return []
     return [float(item.strip()) for item in cleaned.split(";") if item.strip()]
 
 
-def _ensure_required_fields(name: str) -> None:
+def _ensure_required_fields(name: str, variant_name: str) -> None:
     if not name:
         raise ValueError("Pflichtfeld 'name' fehlt.")
+    if not variant_name:
+        raise ValueError("Pflichtfeld 'variant_name' fehlt.")
 
 
 def _validate_csv_headers(headers: List[str] | None) -> str | None:
     if not headers:
         return "Datei enthält keine Kopfzeile."
-    missing = REQUIRED_HEADERS.difference({header.strip() for header in headers})
+    cleaned_headers = {header.strip() for header in headers}
+    missing = REQUIRED_HEADERS.difference(cleaned_headers)
     if missing:
         return f"Pflichtspalten fehlen: {', '.join(sorted(missing))}"
-    unexpected = [h for h in headers if h not in CSV_HEADERS]
+    allowed_headers = set(CSV_HEADERS) | LEGACY_HEADERS
+    unexpected = [h for h in headers if h not in allowed_headers]
     if unexpected:
         return "Unbekannte Spalten gefunden. Bitte Schema prüfen."
     return None
 
 
 def _generate_unique_name(base_name: str, used_names: set[str]) -> str:
     name = base_name
     counter = 1
     while name in used_names:
         name = f"{base_name} ({counter})"
         counter += 1
     used_names.add(name)
     return name
 
 
-def _build_insulation_row(name: str) -> Dict[str, str | float] | None:
+def _build_insulation_rows(name: str) -> List[Dict[str, str | float]] | None:
     data = load_insulation(name)
     if not data:
         return None
-    return {
-        "name": data.get("name", ""),
-        "classification_temp": data.get("classification_temp"),
-        "density": data.get("density"),
-        "length": data.get("length"),
-        "width": data.get("width"),
-        "height": data.get("height"),
-        "price": data.get("price"),
-        "temps": ";".join(map(str, data.get("temps", []))),
-        "ks": ";".join(map(str, data.get("ks", []))),
-    }
+    temps = data.get("temps", [])
+    ks = data.get("ks", [])
+    variants = data.get("variants", []) or [
+        {"name": "Standard", "thickness": "", "length": "", "width": "", "price": ""}
+    ]
+    rows: List[Dict[str, str | float]] = []
+    for variant in variants:
+        rows.append(
+            {
+                "name": data.get("name", ""),
+                "classification_temp": data.get("classification_temp"),
+                "density": data.get("density"),
+                "temps": ";".join(map(str, temps)),
+                "ks": ";".join(map(str, ks)),
+                "variant_name": variant.get("name", ""),
+                "thickness": variant.get("thickness"),
+                "length": variant.get("length"),
+                "width": variant.get("width"),
+                "price": variant.get("price"),
+            }
+        )
+    return rows
 
 
 def _sanitize_filename(name: str) -> str:
     cleaned = re.sub(r"[\\/]+", "_", name).strip()
     cleaned = re.sub(r"[^A-Za-z0-9 _.-]", "_", cleaned)
     cleaned = cleaned or "isolierung"
     return cleaned
diff --git a/app/global_tabs/isolierungen_db/tab.py b/app/global_tabs/isolierungen_db/tab.py
index 076eb5e1c4afea18a95f81ce9aefb576e51dab76..a6cff4a723a45d868f9afbb80108cf081c27faef 100644
--- a/app/global_tabs/isolierungen_db/tab.py
+++ b/app/global_tabs/isolierungen_db/tab.py
@@ -1,293 +1,421 @@
 from __future__ import annotations
 
 import tkinter as tk
 from tkinter import filedialog, messagebox, ttk
 from pathlib import Path
 
 import matplotlib.pyplot as plt
 import numpy as np
 from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
 
 from Isolierung.tabs.scrollable import ScrollableFrame
 from app.global_tabs.isolierungen_db.logic import (
     FileImportResult,
     delete_insulation,
+    delete_variant as delete_variant_entry,
     export_insulations_to_csv,
     export_insulations_to_folder,
     get_all_insulations,
     interpolate_k,
     import_insulations_from_csv_files,
     load_insulation,
-    save_insulation,
+    save_family,
+    save_variant as save_variant_entry,
     register_material_change_listener,
 )
 
 
 class IsolierungenTab:
     def __init__(self, notebook: ttk.Notebook, tab_name: str = "Isolierungen"):
         container = ttk.Frame(notebook, padding=(14, 12, 14, 12))
         notebook.add(container, text=tab_name)
 
         self.scrollable = ScrollableFrame(container)
         self.scrollable.pack(fill="both", expand=True)
 
         self.frame = self.scrollable.inner
         self.build_ui()
         register_material_change_listener(self.refresh_table)
 
     def build_ui(self) -> None:
-        self.frame.rowconfigure(4, weight=1)
+        self.frame.rowconfigure(6, weight=1)
         self.frame.columnconfigure(0, weight=1)
 
         ttk.Label(
             self.frame,
             text="Isolierungen verwalten",
             style="Title.TLabel",
         ).grid(row=0, column=0, columnspan=3, sticky="w", pady=(0, 6))
 
         table_section = ttk.LabelFrame(
-            self.frame, text="Isolierungen", padding=8, style="Section.TLabelframe"
+            self.frame, text="Materialfamilien", padding=8, style="Section.TLabelframe"
         )
-        table_section.grid(row=2, column=0, columnspan=3, sticky="nsew", pady=(0, 8))
+        table_section.grid(row=1, column=0, columnspan=3, sticky="nsew", pady=(0, 8))
         table_section.rowconfigure(1, weight=1)
         table_section.columnconfigure(0, weight=1)
 
-        columns = (
+        family_columns = (
             "name",
             "classification_temp",
             "density",
-            "length",
-            "width",
-            "height",
-            "price",
+            "variant_count",
         )
         self.tree = ttk.Treeview(
             table_section,
-            columns=columns,
+            columns=family_columns,
             show="headings",
-            height=10,
+            height=8,
             selectmode="browse",
         )
-        self.tree.heading("name", text="Name")
+        self.tree.heading("name", text="Familie")
         self.tree.heading("classification_temp", text="Klass.-Temp [°C]")
         self.tree.heading("density", text="Dichte [kg/m³]")
-        self.tree.heading("length", text="Länge [mm]")
-        self.tree.heading("width", text="Breite [mm]")
-        self.tree.heading("height", text="Höhe [mm]")
-        self.tree.heading("price", text="Preis [€]")
-        for column in columns:
-            self.tree.column(column, anchor="center", width=120)
+        self.tree.heading("variant_count", text="Varianten")
+        for column in family_columns:
+            width = 160 if column == "name" else 110
+            self.tree.column(column, anchor="center", width=width)
         self.tree.grid(row=1, column=0, columnspan=2, sticky="nsew", padx=6, pady=4)
-        self.tree.bind("<<TreeviewSelect>>", self.on_select)
+        self.tree.bind("<<TreeviewSelect>>", self.on_family_select)
 
         scrollbar = ttk.Scrollbar(table_section, orient="vertical", command=self.tree.yview)
         self.tree.configure(yscroll=scrollbar.set)
         scrollbar.grid(row=1, column=2, sticky="ns")
 
         action_bar = ttk.Frame(table_section)
         action_bar.grid(row=0, column=0, columnspan=3, sticky="ew", pady=(0, 4))
         for i in range(5):
             action_bar.columnconfigure(i, weight=1)
 
-        ttk.Button(action_bar, text="Neu", command=self.new_entry).grid(
+        ttk.Button(action_bar, text="Neu", command=self.new_family).grid(
             row=0, column=0, sticky="ew", padx=4
         )
-        ttk.Button(action_bar, text="Bearbeiten", command=self.edit_entry).grid(
+        ttk.Button(action_bar, text="Familie löschen", command=self.delete_family).grid(
             row=0, column=1, sticky="ew", padx=4
         )
-        ttk.Button(action_bar, text="Löschen", command=self.delete_entry).grid(
-            row=0, column=2, sticky="ew", padx=4
-        )
         ttk.Button(
             action_bar, text="Exportieren (CSV)", command=self.export_selected
         ).grid(row=0, column=3, sticky="ew", padx=4)
         ttk.Button(action_bar, text="Importieren (CSV)", command=self.import_from_csv).grid(
             row=0, column=4, sticky="ew", padx=4
         )
 
-        form = ttk.LabelFrame(
-            self.frame, text="Isolierung bearbeiten/erstellen", style="Section.TLabelframe"
+        variants_section = ttk.LabelFrame(
+            self.frame, text="Varianten", padding=8, style="Section.TLabelframe"
+        )
+        variants_section.grid(row=2, column=0, columnspan=3, sticky="nsew", pady=(0, 8))
+        variants_section.columnconfigure(0, weight=1)
+        variants_section.rowconfigure(1, weight=1)
+
+        variant_columns = ("variant_name", "thickness", "length", "width", "price")
+        self.variant_tree = ttk.Treeview(
+            variants_section,
+            columns=variant_columns,
+            show="headings",
+            height=6,
+            selectmode="browse",
+        )
+        self.variant_tree.heading("variant_name", text="Variante")
+        self.variant_tree.heading("thickness", text="Dicke [mm]")
+        self.variant_tree.heading("length", text="Länge [mm]")
+        self.variant_tree.heading("width", text="Breite [mm]")
+        self.variant_tree.heading("price", text="Preis [€]")
+        for column in variant_columns:
+            self.variant_tree.column(column, anchor="center", width=115)
+        self.variant_tree.grid(row=1, column=0, columnspan=2, sticky="nsew", padx=6, pady=4)
+        self.variant_tree.bind("<<TreeviewSelect>>", self.on_variant_select)
+
+        variant_scroll = ttk.Scrollbar(
+            variants_section, orient="vertical", command=self.variant_tree.yview
         )
-        form.grid(row=3, column=0, columnspan=3, sticky="ew", pady=(0, 8))
-        form.columnconfigure(1, weight=1)
-        form.columnconfigure(3, weight=1)
+        self.variant_tree.configure(yscroll=variant_scroll.set)
+        variant_scroll.grid(row=1, column=2, sticky="ns")
+
+        variant_action_bar = ttk.Frame(variants_section)
+        variant_action_bar.grid(row=0, column=0, columnspan=3, sticky="ew", pady=(0, 4))
+        for i in range(3):
+            variant_action_bar.columnconfigure(i, weight=1)
+
+        ttk.Button(variant_action_bar, text="Neue Variante", command=self.new_variant).grid(
+            row=0, column=0, sticky="ew", padx=4
+        )
+        ttk.Button(
+            variant_action_bar, text="Variante löschen", command=self.delete_variant
+        ).grid(row=0, column=1, sticky="ew", padx=4)
 
-        # Stammdaten
-        ttk.Label(form, text="Name:").grid(row=0, column=0, sticky="w")
-        self.entry_name = ttk.Entry(form)
+        family_form = ttk.LabelFrame(
+            self.frame, text="Stammdaten", style="Section.TLabelframe"
+        )
+        family_form.grid(row=3, column=0, columnspan=3, sticky="ew", pady=(0, 8))
+        family_form.columnconfigure(1, weight=1)
+        family_form.columnconfigure(3, weight=1)
+
+        ttk.Label(family_form, text="Familienname:").grid(row=0, column=0, sticky="w")
+        self.entry_name = ttk.Entry(family_form)
         self.entry_name.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
 
-        ttk.Label(form, text="Klass.-Temp [°C]:").grid(row=1, column=0, sticky="w")
-        self.entry_class_temp = ttk.Entry(form)
+        ttk.Label(family_form, text="Klass.-Temp [°C]:").grid(row=1, column=0, sticky="w")
+        self.entry_class_temp = ttk.Entry(family_form)
         self.entry_class_temp.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
 
-        ttk.Label(form, text="Dichte [kg/m³]:").grid(row=2, column=0, sticky="w")
-        self.entry_density = ttk.Entry(form)
+        ttk.Label(family_form, text="Dichte [kg/m³]:").grid(row=2, column=0, sticky="w")
+        self.entry_density = ttk.Entry(family_form)
         self.entry_density.grid(row=2, column=1, sticky="ew", padx=5, pady=2)
 
-        # Abmessungen & Preis
-        ttk.Label(form, text="Länge [mm]:").grid(row=0, column=2, sticky="w")
-        self.entry_length = ttk.Entry(form)
-        self.entry_length.grid(row=0, column=3, sticky="ew", padx=5, pady=2)
+        ttk.Label(family_form, text="Temperaturen [°C]:").grid(row=3, column=0, sticky="w")
+        self.entry_temps = ttk.Entry(family_form)
+        self.entry_temps.grid(row=3, column=1, sticky="ew", padx=5, pady=2)
 
-        ttk.Label(form, text="Breite [mm]:").grid(row=1, column=2, sticky="w")
-        self.entry_width = ttk.Entry(form)
-        self.entry_width.grid(row=1, column=3, sticky="ew", padx=5, pady=2)
+        ttk.Label(family_form, text="Wärmeleitfähigkeiten [W/mK]:").grid(
+            row=4, column=0, sticky="w"
+        )
+        self.entry_ks = ttk.Entry(family_form)
+        self.entry_ks.grid(row=4, column=1, sticky="ew", padx=5, pady=2)
 
-        ttk.Label(form, text="Höhe [mm]:").grid(row=2, column=2, sticky="w")
-        self.entry_height = ttk.Entry(form)
-        self.entry_height.grid(row=2, column=3, sticky="ew", padx=5, pady=2)
+        ttk.Button(
+            family_form, text="Stammdaten speichern", command=self.save_family
+        ).grid(row=5, column=0, columnspan=4, pady=8, sticky="e")
 
-        ttk.Label(form, text="Preis [€/Platte]:").grid(row=3, column=2, sticky="w")
-        self.entry_price = ttk.Entry(form)
-        self.entry_price.grid(row=3, column=3, sticky="ew", padx=5, pady=2)
+        variant_form = ttk.LabelFrame(
+            self.frame, text="Variante bearbeiten", style="Section.TLabelframe"
+        )
+        variant_form.grid(row=4, column=0, columnspan=3, sticky="ew", pady=(0, 8))
+        variant_form.columnconfigure(1, weight=1)
+        variant_form.columnconfigure(3, weight=1)
 
-        # Messwerte
-        ttk.Label(form, text="Temperaturen [°C]:").grid(row=3, column=0, sticky="w")
-        self.entry_temps = ttk.Entry(form)
-        self.entry_temps.grid(row=3, column=1, sticky="ew", padx=5, pady=2)
+        ttk.Label(variant_form, text="Variante:").grid(row=0, column=0, sticky="w")
+        self.entry_variant_name = ttk.Entry(variant_form)
+        self.entry_variant_name.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
 
-        ttk.Label(form, text="Wärmeleitfähigkeiten [W/mK]:").grid(row=4, column=0, sticky="w")
-        self.entry_ks = ttk.Entry(form)
-        self.entry_ks.grid(row=4, column=1, sticky="ew", padx=5, pady=2)
+        ttk.Label(variant_form, text="Dicke [mm]:").grid(row=1, column=0, sticky="w")
+        self.entry_thickness = ttk.Entry(variant_form)
+        self.entry_thickness.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
+
+        ttk.Label(variant_form, text="Länge [mm]:").grid(row=0, column=2, sticky="w")
+        self.entry_length = ttk.Entry(variant_form)
+        self.entry_length.grid(row=0, column=3, sticky="ew", padx=5, pady=2)
+
+        ttk.Label(variant_form, text="Breite [mm]:").grid(row=1, column=2, sticky="w")
+        self.entry_width = ttk.Entry(variant_form)
+        self.entry_width.grid(row=1, column=3, sticky="ew", padx=5, pady=2)
+
+        ttk.Label(variant_form, text="Preis [€/Platte]:").grid(row=2, column=0, sticky="w")
+        self.entry_price = ttk.Entry(variant_form)
+        self.entry_price.grid(row=2, column=1, sticky="ew", padx=5, pady=2)
 
         ttk.Button(
-            form, text="💾 Speichern", style="Accent.TButton", command=self.save_entry
-        ).grid(row=5, column=0, columnspan=4, pady=10, sticky="e")
+            variant_form, text="Variante speichern", style="Accent.TButton", command=self.save_variant
+        ).grid(row=3, column=0, columnspan=4, pady=10, sticky="e")
 
         self.plot_frame = ttk.LabelFrame(
             self.frame,
             text="Interpolierte Wärmeleitfähigkeit",
             style="Section.TLabelframe",
         )
-        self.plot_frame.grid(row=4, column=0, columnspan=3, sticky="nsew", pady=(0, 4))
-        self.frame.rowconfigure(4, weight=1)
+        self.plot_frame.grid(row=5, column=0, columnspan=3, sticky="nsew", pady=(0, 4))
+        self.frame.rowconfigure(5, weight=1)
         self.refresh_table()
 
     def refresh_table(self) -> None:
         self.tree.delete(*self.tree.get_children())
         for insulation in get_all_insulations():
             self.tree.insert(
                 "",
                 "end",
                 values=(
                     insulation.get("name", ""),
                     insulation.get("classification_temp", ""),
                     insulation.get("density", ""),
-                    insulation.get("length", ""),
-                    insulation.get("width", ""),
-                    insulation.get("height", ""),
-                    insulation.get("price", ""),
+                    insulation.get("variant_count", 0),
                 ),
             )
+        self.variant_tree.delete(*self.variant_tree.get_children())
 
-    def new_entry(self) -> None:
+    def new_family(self) -> None:
         self.clear_fields()
+        self.variant_tree.delete(*self.variant_tree.get_children())
 
-    def edit_entry(self) -> None:
+    def on_family_select(self, event: tk.Event | None = None) -> None:
         selection = self.tree.selection()
         if not selection:
-            messagebox.showinfo("Hinweis", "Bitte eine Isolierung auswählen.")
             return
         name = self.tree.item(selection[0])["values"][0]
         data = load_insulation(name)
         if not data:
             return
+        self._fill_family_form(data)
+        self._populate_variants(data.get("variants", []))
+        self.update_plot(data.get("temps", []), data.get("ks", []), data.get("classification_temp"))
+
+    def _fill_family_form(self, data: dict) -> None:
         self.entry_name.delete(0, tk.END)
-        self.entry_name.insert(0, data["name"])
+        self.entry_name.insert(0, data.get("name", ""))
         self.entry_class_temp.delete(0, tk.END)
         if data.get("classification_temp") is not None:
             self.entry_class_temp.insert(0, str(data["classification_temp"]))
         self.entry_density.delete(0, tk.END)
         if data.get("density") is not None:
             self.entry_density.insert(0, str(data["density"]))
+        self.entry_temps.delete(0, tk.END)
+        self.entry_temps.insert(0, ", ".join(map(str, data.get("temps", []))))
+        self.entry_ks.delete(0, tk.END)
+        self.entry_ks.insert(0, ", ".join(map(str, data.get("ks", []))))
+
+    def _populate_variants(self, variants: list[dict]) -> None:
+        self.variant_tree.delete(*self.variant_tree.get_children())
+        for variant in variants:
+            self.variant_tree.insert(
+                "",
+                "end",
+                values=(
+                    variant.get("name", ""),
+                    variant.get("thickness", ""),
+                    variant.get("length", ""),
+                    variant.get("width", ""),
+                    variant.get("price", ""),
+                ),
+            )
+
+    def new_variant(self) -> None:
+        self.entry_variant_name.delete(0, tk.END)
+        self.entry_thickness.delete(0, tk.END)
         self.entry_length.delete(0, tk.END)
-        if data.get("length") is not None:
-            self.entry_length.insert(0, str(data["length"]))
         self.entry_width.delete(0, tk.END)
-        if data.get("width") is not None:
-            self.entry_width.insert(0, str(data["width"]))
-        self.entry_height.delete(0, tk.END)
-        if data.get("height") is not None:
-            self.entry_height.insert(0, str(data["height"]))
         self.entry_price.delete(0, tk.END)
-        if data.get("price") is not None:
-            self.entry_price.insert(0, str(data["price"]))
-        self.entry_temps.delete(0, tk.END)
-        self.entry_temps.insert(0, ", ".join(map(str, data["temps"])))
-        self.entry_ks.delete(0, tk.END)
-        self.entry_ks.insert(0, ", ".join(map(str, data["ks"])))
-        self.update_plot(data["temps"], data["ks"], data["classification_temp"])
 
-    def save_entry(self) -> None:
+    def on_variant_select(self, event: tk.Event | None = None) -> None:
+        selection = self.variant_tree.selection()
+        if not selection:
+            return
+        values = self.variant_tree.item(selection[0])["values"]
+        fields = [
+            self.entry_variant_name,
+            self.entry_thickness,
+            self.entry_length,
+            self.entry_width,
+            self.entry_price,
+        ]
+        for entry, value in zip(fields, values):
+            entry.delete(0, tk.END)
+            if value not in (None, ""):
+                entry.insert(0, str(value))
+
+    def save_family(self) -> None:
         try:
             name = self.entry_name.get().strip()
             if not name:
-                messagebox.showwarning("Fehler", "Name darf nicht leer sein.")
+                messagebox.showwarning("Fehler", "Familienname darf nicht leer sein.")
                 return
             class_temp = self._parse_required_float(self.entry_class_temp.get(), "Klass.-Temp")
             density = self._parse_required_float(self.entry_density.get(), "Dichte")
-            length = self._parse_optional_float(self.entry_length.get())
-            width = self._parse_optional_float(self.entry_width.get())
-            height = self._parse_optional_float(self.entry_height.get())
-            price = self._parse_optional_float(self.entry_price.get())
             temps = [float(x.strip()) for x in self.entry_temps.get().split(",") if x.strip()]
             ks = [float(x.strip()) for x in self.entry_ks.get().split(",") if x.strip()]
             if len(temps) != len(ks):
                 messagebox.showerror(
                     "Fehler", "Temperatur- und k-Werte müssen gleich viele Einträge haben."
                 )
                 return
-            save_insulation(name, class_temp, density, length, width, height, price, temps, ks)
-            messagebox.showinfo("Gespeichert", f"Isolierung '{name}' wurde gespeichert.")
+            save_family(name, class_temp, density, temps, ks)
+            messagebox.showinfo("Gespeichert", f"Familie '{name}' wurde gespeichert.")
             self.refresh_table()
         except Exception as exc:  # pragma: no cover - GUI Verarbeitung
             messagebox.showerror("Fehler", str(exc))
 
-    def delete_entry(self) -> None:
+    def save_variant(self) -> None:
+        try:
+            family_name = self.entry_name.get().strip()
+            if not family_name:
+                messagebox.showwarning("Fehler", "Bitte zuerst eine Familie auswählen.")
+                return
+            variant_name = self.entry_variant_name.get().strip() or "Standard"
+            thickness = self._parse_required_float(
+                self.entry_thickness.get(), "Dicke"
+            )
+            length = self._parse_optional_float(self.entry_length.get())
+            width = self._parse_optional_float(self.entry_width.get())
+            price = self._parse_optional_float(self.entry_price.get())
+            saved = save_variant_entry(
+                family_name, variant_name, thickness, length, width, price
+            )
+            if saved:
+                messagebox.showinfo(
+                    "Gespeichert",
+                    f"Variante '{variant_name}' wurde für '{family_name}' gespeichert.",
+                )
+                self.on_family_select()
+            else:
+                messagebox.showerror(
+                    "Fehler",
+                    "Variante konnte nicht gespeichert werden. Bitte Familie prüfen.",
+                )
+        except Exception as exc:  # pragma: no cover - GUI Verarbeitung
+            messagebox.showerror("Fehler", str(exc))
+
+    def delete_family(self) -> None:
         selection = self.tree.selection()
         if not selection:
             messagebox.showinfo("Hinweis", "Bitte eine Isolierung auswählen.")
             return
         name = self.tree.item(selection[0])["values"][0]
         if messagebox.askyesno(
             "Löschen bestätigen",
             (
                 f"Soll das Material '{name}' endgültig gelöscht werden?\n"
                 "Dieser Vorgang kann nicht rückgängig gemacht werden."
             ),
         ):
             if delete_insulation(name):
                 self.refresh_table()
                 self.clear_fields()
             else:
                 messagebox.showerror(
                     "Löschen fehlgeschlagen",
                     "Das Material konnte nicht gelöscht werden.",
                 )
 
+    def delete_variant(self) -> None:
+        family_name = self.entry_name.get().strip()
+        selection = self.variant_tree.selection()
+        if not family_name or not selection:
+            messagebox.showinfo(
+                "Hinweis", "Bitte zuerst eine Familie und Variante auswählen."
+            )
+            return
+        variant_name = self.variant_tree.item(selection[0])["values"][0]
+        if messagebox.askyesno(
+            "Variante löschen",
+            f"Soll die Variante '{variant_name}' aus '{family_name}' gelöscht werden?",
+        ):
+            if delete_variant_entry(family_name, variant_name):
+                self.on_family_select()
+                self.new_variant()
+            else:
+                messagebox.showerror(
+                    "Löschen fehlgeschlagen",
+                    "Die Variante konnte nicht gelöscht werden.",
+                )
+
     def export_selected(self) -> None:
         preselected = set()
         if self.tree.selection():
             preselected.add(self.tree.item(self.tree.selection()[0])["values"][0])
 
         dialog = tk.Toplevel(self.frame)
         dialog.title("Isolierungen exportieren")
         dialog.transient(self.frame)
         dialog.grab_set()
 
         ttk.Label(
             dialog,
             text="Bitte wählen Sie ein oder mehrere Isolierungen für den Export aus:",
         ).pack(anchor="w", padx=12, pady=(12, 6))
 
         list_frame = ttk.Frame(dialog)
         list_frame.pack(fill="both", expand=True, padx=12)
 
         canvas = tk.Canvas(list_frame, borderwidth=0, highlightthickness=0, height=240)
         scrollbar = ttk.Scrollbar(list_frame, orient="vertical", command=canvas.yview)
         canvas.configure(yscrollcommand=scrollbar.set)
         scrollbar.pack(side="right", fill="y")
         canvas.pack(side="left", fill="both", expand=True)
 
         inner = ttk.Frame(canvas)
@@ -385,87 +513,83 @@ class IsolierungenTab:
             message = self._build_import_summary(imported, results)
             messagebox.showinfo("Import abgeschlossen", message)
         except Exception as exc:  # pragma: no cover - GUI Verarbeitung
             messagebox.showerror("Import fehlgeschlagen", str(exc))
 
     def _build_import_summary(
         self, imported: int, results: list[FileImportResult]
     ) -> str:
         lines = [f"{imported} Isolierung(en) importiert."]
         skipped = [r for r in results if r.skipped_reason]
         per_file_errors = [r for r in results if r.errors]
 
         if skipped:
             lines.append("Übersprungene Dateien:")
             for result in skipped:
                 lines.append(f"- {Path(result.file_path).name}: {result.skipped_reason}")
 
         if per_file_errors:
             lines.append("Fehlerhafte Zeilen:")
             for result in per_file_errors:
                 lines.append(f"- {Path(result.file_path).name}:")
                 lines.extend([f"    * {err}" for err in result.errors])
 
         return "\n".join(lines)
 
-    def on_select(self, event: tk.Event | None = None) -> None:
-        selection = self.tree.selection()
-        if not selection:
-            return
-        name = self.tree.item(selection[0])["values"][0]
-        data = load_insulation(name)
-        if data:
-            self.update_plot(data["temps"], data["ks"], data["classification_temp"])
-
     def clear_fields(self) -> None:
         for entry in [
             self.entry_name,
             self.entry_class_temp,
             self.entry_density,
             self.entry_length,
             self.entry_width,
-            self.entry_height,
             self.entry_price,
             self.entry_temps,
             self.entry_ks,
+            self.entry_variant_name,
+            self.entry_thickness,
         ]:
             entry.delete(0, tk.END)
 
     def _parse_required_float(self, value: str, label: str) -> float:
         cleaned = value.strip()
         if not cleaned:
             raise ValueError(f"{label} darf nicht leer sein.")
         try:
             return float(cleaned)
         except ValueError:
             raise ValueError(f"{label} muss eine Zahl sein.")
 
     def _parse_optional_float(self, value: str) -> float | None:
         cleaned = value.strip()
         if not cleaned:
             return None
         try:
             return float(cleaned)
         except ValueError:
             raise ValueError("Numerischer Wert erwartet (optional).")
 
     def update_plot(self, temps, ks, class_temp) -> None:
         try:
+            if not temps or not ks:
+                for widget in self.plot_frame.winfo_children():
+                    widget.destroy()
+                return
             max_temp = class_temp if class_temp is not None else (max(temps) if temps else 20)
             x = np.linspace(20, max_temp, 100)
             y = interpolate_k(temps, ks, x)
             plt.close("all")
             fig, ax = plt.subplots(figsize=(6, 4), dpi=100)
             ax.plot(x, y, linewidth=2, label="Interpoliert")
             ax.scatter(temps, ks, color="red", zorder=5, label="Messpunkte")
             ax.set_xlabel("Temperatur [°C]")
             ax.set_ylabel("Wärmeleitfähigkeit [W/mK]")
             ax.set_title("Wärmeleitfähigkeit über Temperatur")
             ax.legend()
             ax.grid(True, linestyle="--", alpha=0.6)
             for widget in self.plot_frame.winfo_children():
                 widget.destroy()
             canvas = FigureCanvasTkAgg(fig, master=self.plot_frame)
             canvas.draw()
             canvas.get_tk_widget().pack(fill="both", expand=True)
         except Exception as exc:  # pragma: no cover - GUI Verarbeitung
             messagebox.showerror("Fehler beim Plotten", str(exc))
